
ProcessBuilder processBuilder = new ProcessBuilder("cat", "/msk/input_json.json");
            
            // Start the process
            Process process = processBuilder.start();
            
            // Read the output of the command
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
                StringBuilder jsonMessageBuilder = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    jsonMessageBuilder.append(line);
                }
                
                String jsonMessage = jsonMessageBuilder.toString();

                // Optionally parse and validate the JSON
                JsonNode jsonNode = objectMapper.readTree(jsonMessage);
try (BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
                StringBuilder errorMessage = new StringBuilder();
                String errorLine;
                while ((errorLine = errorReader.readLine()) != null) {
                    errorMessage.append(errorLine).append("\n");
                }
                if (errorMessage.length() > 0) {
                    System.err.println("Error output from process: " + errorMessage);
                }
            }
====================================================================================================================
 if (rootNode.isArray()) {
                List<JsonNode> messages = rootNode.findValuesAsText("data").stream().map(node -> node.asText()).collect(Collectors.toList());

                // Extract and process the required fields
                List<Map<String, String>> processedMessages = messages.stream()
                        .map(this::extractFields)
                        .filter(java.util.Objects::nonNull)
                        .sorted((m1, m2) -> m1.get("time").compareTo(m2.get("time")))
                        .collect(Collectors.toList());

                // Group messages by evtNme
                Map<String, List<Map<String, String>>> groupedMessages = processedMessages.stream()
                        .collect(Collectors.groupingBy(m -> m.get("evtNme")));

                // Process grouped messages as needed
                groupedMessages.forEach((evtNme, group) -> {
                    System.out.println("Event Name: " + evtNme);
                    group.forEach(message -> {
                        System.out.println("Time: " + message.get("time"));
                        System.out.println("Fiscorrelationid: " + message.get("fiscorrelationid"));
                        // Add any additional processing here
                    });
                });
            } else {
                System.out.println("Received message is not a JSON array.");
            }








































Properties props = new Properties();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "your-msk-broker:9098");
        props.put(ConsumerConfig.GROUP_ID_CONFIG, "my-testgroup-id");
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");

        KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props);
        consumer.subscribe(Collections.singletonList("DDSLtest"));

        while (true) {
            ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(1000));
            for (ConsumerRecord<String, String> record : records) {
                System.out.printf("Consumed record with key %s and value %s%n", record.key(), record.value());
            }
        }
    }
-----------------------------------------------------------------------------------------------------------------------------------------
try {
            // Convert the message to JsonNode
            JsonNode rootNode = objectMapper.readTree(record.value());

            // Check if the root node is an array (for multiple JSON objects in a single message)
            List<JsonNode> messages;
            if (rootNode.isArray()) {
                messages = new ArrayList<>();
                rootNode.forEach(messages::add);
            } else {
                // If not an array, treat the single message as a list of one
                messages = List.of(rootNode);
            }

            // Extract and process the required fields
            List<Map<String, String>> processedMessages = messages.stream()
                    .map(this::extractFields)
                    .filter(java.util.Objects::nonNull)
                    .sorted(Comparator.comparing(m -> m.get("time")))
                    .collect(Collectors.toList());

            // Group messages by evtNme
            Map<String, List<Map<String, String>>> groupedMessages = processedMessages.stream()
                    .collect(Collectors.groupingBy(m -> m.get("evtNme")));

            // Process grouped messages as needed
            groupedMessages.forEach((evtNme, group) -> {
                System.out.println("Event Name: " + evtNme);
                group.forEach(message -> {
                    System.out.println("Time: " + message.get("time"));
                    System.out.println("Fiscorrelationid: " + message.get("fiscorrelationid"));
                    // Add any additional processing here
                });
            });

        } catch (Exception e) {
            e.printStackTrace();
            // Handle exceptions such as JSON parsing errors
        }
    }

    // Helper method to extract the required fields from the JSON
    private Map<String, String> extractFields(JsonNode jsonNode) {
        try {
            String time = jsonNode.get("time").asText();
            String evtNme = jsonNode.get("evtNme").asText();
            String fiscorrelationid = jsonNode.get("fiscorrelationid").asText();

            return Map.of("time", time, "evtNme", evtNme, "fiscorrelationid", fiscorrelationid);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
------------------------------------------------------------------------------------------------------
 private Map<String, String> extractFields(JsonNode jsonNode) {
        try {
            // Safely extract fields with null checks
            String time = jsonNode.has("time") ? jsonNode.get("time").asText() : null;
            String fiscorrelationid = jsonNode.has("fiscorrelationid") ? jsonNode.get("fiscorrelationid").asText() : null;

            // Navigate to nested "evtNme"
            JsonNode evtNmeNode = jsonNode.path("data").path("ad").path("evtNme");
            String evtNme = evtNmeNode.isMissingNode() ? null : evtNmeNode.asText();

            // Only return the map if all required fields are present
            if (time != null && evtNme != null && fiscorrelationid != null) {
                return Map.of("time", time, "evtNme", evtNme, "fiscorrelationid", fiscorrelationid);
            } else {
                return null;
            }
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
